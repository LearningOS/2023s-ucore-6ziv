# chapter8 练习

王哲威（[https://github.com/LearningOS/2023s-ucore-6ziv](https://github.com/LearningOS/2023s-ucore-6ziv)）

#### 简单总结实现的功能：

添加了`enable_deadlock_detect`系统调用，并在`deadlock_detect`函数中实现了银行家算法。

将`mutex`看作”数量限制为1“的`semaphore`，则可以将二者用同样的方式进行死锁检测。在每轮检测中，反复寻找对各种资源的需求都能被满足的线程，假设它可以运行并释放它持有的所有资源。重复进行这样的操作，如果最后所有线程都能结束，则认为当前处于”安全“状态。

这种检测方式在检测信号量死锁可能出现误检：我们认为资源被线程”持有“，但是在类似`ch8b_mpsc_sem`的情况下，信号量被一个线程释放并被另一个线程获取，银行家算法无法正确处理这种情况。

#### 问答作业

> 在我们的多线程实现中，当主线程 (即 0 号线程) 退出时，视为整个进程退出， 此时需要结束该进程管理的所有线程并回收其资源。

> - 需要回收的资源有哪些？

需要回收页表中映射的页，以及打开的文件句柄。

互斥量、信号量等仅在进程内有效，因此没有回收的必要；页表项占用了物理内存、文件句柄占用了相应的`inode`，因此这两项需要被回收。

> * 其他线程的 `struct thread` 可能在哪些位置被引用，分别是否需要回收，为什么？

可能在调度器中被引用。但是我们在`freethread`时将线程标记为`exited`，调度器接下来就会跳过已经退出的线程。

> 对比以下两种 `mutex_unlock` 中阻塞锁的实现，二者有什么区别？这些区别可能会导致什么问题？ （假设无论哪种实现，对应的 `mutex_lock` 均正确处理了 `m->locked`）
> 
> （代码略）

`mutex_unlock_v1`释放了`mutex`，之后将`wait_queue`中的线程加入到调度器中，不妨记为`A`。如果在`mutex_unlock_v1`被调用之后、线程`A`被调度到之前，有另一个线程`B`插入到其中申请了`mutex`，那么有可能`B`反而先于`A`获得`mutex`。

如果两个线程轮流获得/释放`mutex`，那么有可能一直都是同一个线程获得互斥量而另一个线程处于饥饿状态。

`mutex_unlock_v2`则更注重公平性。当`mutex`被”释放“时，并不把它的`locked`置`0`，因此其它线程无法获取这个`mutex`。从`wait_queue`中取出的线程会直接获得被释放的`mutex`。
